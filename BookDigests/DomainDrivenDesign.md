# Book Digest: Domain-Driven Design: Tackling Complexity In The Heart Of Software

Title     : Domain-Driven Design: Tackling Complexity In The Heart Of Software  
Author(s) : Eric Evans  
ISBN-10   : 0321125215  
ISBN-13   : 978-0321125217  

## Chapter 1 - Crunching Knowledge
- Every software program relates to some activity or interest of its user. That subject area to which the user applies the program is the domain of the software.
- Every model represents some aspect of reality or an idea that is of interest. A model is a simplification. It is an interpretation of reality that abstracts the aspects relevant to solving the problem at hand and ignores extraneous detail.
- A domain model is a rigorously organized and selective abstraction of the knowledge in a domain expert's head.
- Most developers do not have much interest in learning about the specific domain in which they are working and prefer quantifiable problems that exercise their technical skills, yet it is the domain that holds the complexity and must be understood in order to produce elegant software.
- The ingredients of effective modelling are binding the model and the implementation, cultivating a language based on the model, embedding knowledge within the model and distilling the model (removing concepts not important or central).
- Knowledge crunching is between a team of developers and domain experts who collaborate.  The raw material comes from the minds of domain experts which is then interpreted by the development team and fed back to the domain experts for feedback and review.  In the old waterfall method, the business experts talk to the analysts, and analysts digest and abstract and pass the result along to the programmers, who code the software. This approach fails because it completely lacks feedback.
- Other projects use an iterative process, but they fail to build up knowledge because they don't abstract. Developers get the experts to describe a desired feature and then they go build it. They show the experts the result and ask what to do next. If the programmers practice refactoring, they can keep the software clean enough to continue extending it, but if programmers are not interested in the domain, they learn only what the application should do, not the principles behind it.
- Models are never perfect; they evolve. They must be practical and useful in making sense of the domain. They must be rigorous enough to make the application simple to implement and understand.

## Chapter 2 - Communication And Use Of Language
- A project needs a common language that is more robust than a lowest common denominator between domain experts and developers.  This language should be expressed in the terms of the domain, to minimise the need for translation between languages and dialects.
- This language is the "ubiquitous language" of the domain and must be shared by developers and domain experts across all communication.  The domain model is the backbone of this language and the language, like the model itself, can evolve.
- With a ubiquitous language, the model is not just a design artefact. It becomes integral to everything the developers and domain experts do together. The LANGUAGE carries knowledge in a dynamic form. Discussion in the language brings to life the meaning behind the diagrams and code.
- Use the ubiquitous language to help refine your model.  Turn phrases like "If we give the _Routing Service_ an origin, destination, and arrival time, it can look up the stops the cargo will have to make" into "A _Routing Service_ finds an _Itinerary_ that satisfies a _Route Specification_."
- Resist the temptation to try to "shield" business users from the model in the belief that it may be too abstract.  You won't know the domain as well as them so you need to make sure the abstractions are sound. If sophisticated domain experts don't understand the model, there is something wrong with the model.
- It's fine to use UML diagrams for documenting the model, but be careful not to include too much detail.  Rather than produce a complete model as a diagram with text annotations, aim for a textual document illustrated with selective and simplified diagrams.  Explanatory models should not be object models.
- Documents should clarify design intent and should not try to do what the program code already does well in supplying the detail.
- It takes fastidiousness to write code that doesn't just _do_ the right thing but also _says_ the right thing..
- One model should underlie implementation, design, and team communication.  Having more than one model for these separate purposes can cause confusion and create problems for the project.

## Chapter 3 - Binding Model And Implementation
- Projects that have no domain model at all, but just write code to fulfil one function after another will be swamped by a complex domain. Conversely, some complex projects have a domain model but don't maintain a tight connection between the model and the actual program code.
- Be careful not to create analysis models that are removed from the actual design and code of the solution.  Models should serve as the foundation of both analysis and design and be tight connected so that insight gained in one area directly feeds into the other.
- Design a portion of the software system to reflect the domain model in a very literal way, so that mapping is obvious. Revisit the model and modify it to be implemented more naturally in software, even as you seek to make it reflect deeper insight into the domain. Demand a single model that serves both purposes well, in addition to supporting a robust ubiquitous language.
- Do not try to completely hide the existence of the domain model from the user of the finished software.  Beware of such abstractions that cause confusion for users and complicate the model.
- Remember that all software development is design.  There's no such thing as no design, there's only either good design or bad design.
- Any technical person contributing to the model must spend some time touching the code, whatever primary role he or she plays on the project. Anyone responsible for changing code must learn to express a model through the code. Every developer must be involved in some level of discussion about the model and have contact with domain experts. Those who contribute in different ways must consciously engage those who touch the code in a dynamic exchange of model ideas through the ubiquitous language.
- Developing a good domain model is an art. But the practical design and implementation of a model's individual elements can be relatively systematic.

## Chapter 4 - Isolating The Domain
- The part of the software that solves problems from the domain is usually only a small part of a much larger whole, yet it is of vital importance and it is also crucially important that we're able to isolate our domain model from other software concerns.
- Many software programs end up with business logic embedded throughout UI, database and other support code which makes it extremely difficult to see and reason about.
- The software program should be partitioned into layers using standard architectural patterns to ensure that layers are not tightly coupled to one another.
- If using software frameworks (i.e. ORM, MVC etc.), the team needs to ensure the framework does not impede the goal of building an implementation that expresses a domain model and uses it to solve important domain problems.
- In a model-driven design, the software constructs of the domain layer mirror the model concepts and the "domain layer" is the manifestation of that model and all directly related design elements.
- Isolating the domain implementation is a prerequisite for domain-driven design.
- If the project is simple, avoid using model-driven design. The overhead of managing infrastructure and layers makes very simple tasks take longer.

## Chapter 5 - A Model Expressed In Software
- Model elements are expressed as Entities, Value Objects or Services.
- Entities have identity and continuity whilst value objects are attributes that describe the state of something else.
- Services are aspects of the domain that are more clearly expressed as actions or operations.  They are performed for a client upon request.
- Objects can be associated with other objects.  For every traversable association in the model, there is a mechanism in the software with the same properties.
- Associations should have explicit traversal directions and a multiplicity qualifier to help eliminate nonessential associations and simplify the model.
- Entities are not defined by any attribute.  They represent a thread of identity that runs through time and often across distinct representations, which can have different attributes.
- Entity identity should not be confused with programmatic identity between two reference objects (i.e. == operator).
- When an object is distinguished by its identity, rather than its attributes, make this primary to its definition in the model. Define an operation that is guaranteed to produce a unique result for each object, possibly by attaching a symbol that is guaranteed unique and define a means of distinguishing each object regardless of its form or history, remaining alert to requirements that call for matching objects by attributes.
- Entities must have some identifier that designates the identity.  This can be a combination of attributes that provide uniqueness (but watch out for attributes changing).  It is often better to be a unique ID number or string that once assigned is immutable.
- Identity-assigning operations often involve human input in order for the ID's to have some meaningful distinction within the domain.
- Tracking the identity of entities is essential, but attaching identity to other objects can hurt system performance, add analytical work, and muddle the model by making all objects look the same.
- Value Objects represent a descriptive aspect of the domain with no conceptual identity.  Value Objects are instantiated to represent elements of the design that we care about only for what they are, not who or which they are.
- The attributes that make up a value object should form a conceptual whole. For example, street, city, and postal code shouldn't be separate attributes of a Person object. They are part of a single, whole address, which makes a simpler Person, and a more coherent Value Object.
- Value Objects can be shared between other domain objects due to their interchangeable nature, however, in order to prevent changes in one objects values being reflected in another, value objects should be immutable.
- Note that bidirectional associations between two Value Objects make no sense as without identity the association really only infers equality of the values and not the identity.
- There are important domain operations that can't find a natural home in an Entity or Value Object. Some of these are intrinsically activities or actions, not things, but since our modelling paradigm is objects, we try to fit them into objects anyway.
- Some concepts from the domain aren't natural to model as objects. Forcing the required domain functionality to be the responsibility of an entity or value either distorts the definition of a model-based object or adds meaningless artificial objects.
- Services are named after what they can do for a client.  They use verbs rather than nouns and are part of the domain's ubiquitous language.
- Services should be used judiciously and not allowed to strip the Entities and Value Objects of all their behaviour.
- Good services relate to a domain concept that is not a natural part of any value object or entity, whose interface is defined in terms of other elements of the domain model and whose operation is stateless.
- Be careful to distinguish infrastructure services from domain services.  Most services are infrastructure services as they are not part of the core domain and lack any business meaning at all (i.e. an email sending service is unlikely to be a core domain concern).
- Modules (aka Packages) should be used in the domain layer should emerge as a meaningful part of the model, telling the story of the domain on a larger scale.
- Choose Modules that tell the story of the system and contain a cohesive set of concepts.  Seek low coupling between modules and give modules names as part of the ubiquitous language.
- Refactoring of modules often requires more work than refactoring of classes, so pay attention to changes to the domain model that require module changes and seek to make the changes as soon as possible.
- Beware of frameworks that use conventions that would pull apart elements that implement the same conceptual model as the code can be left in a state that it no longer reveals the domain model.
- Use packaging to separate the domain layer from other code. Otherwise, leave as much freedom as possible to the domain developers to package the domain objects in ways that support their model and design choices.
- Most projects attempting Model-Driven Design are wise to use object-oriented technology as the core of their system as it's a proven technology that is well understood and fits well with domain modelling.
- If you must mix modelling paradigms (i.e. OOP and RDBMS), don't fight the implementation paradigm but ensure that concepts are named in the ubiquitous language to help relate to the model and aid understanding.

## Chapter 6 - The Life Cycle Of A Domain Object
- It is difficult to guarantee the consistency of changes to objects in a model with complex associations. Invariants need to be maintained that apply to closely related groups of objects, not just discrete objects. Yet cautious locking schemes cause multiple users to interfere pointlessly with each other and make a system unusable.
- AGGREGATES mark off the scope within which invariants have to be maintained at every stage of the life cycle. FACTORIES and REPOSITORIES operate on AGGREGATES, encapsulating the complexity of specific life cycle transitions.
- An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes. Each AGGREGATE has a root and a boundary. The boundary defines what is inside the AGGREGATE. The root is a single, specific ENTITY contained in the AGGREGATE. The root is the only member of the AGGREGATE that outside objects are allowed to hold references to, although objects within the boundary may hold references to each other.
- Invariants, which are consistency rules that must be maintained whenever data changes, will involve relationships between members of the AGGREGATE. Any rule that spans AGGREGATES will not be expected to be up-to-date at all times.
- Objects within the AGGREGATE can hold references to other AGGREGATE roots and a delete operation must remove everything within the AGGREGATE boundary at once.
- When a change to any object within the AGGREGATE boundary is committed, all invariants of the whole AGGREGATE must be satisfied.
- When creation of an object, or an entire AGGREGATE, becomes complicated or reveals too much of the internal structure, FACTORIES provide encapsulation.
- Creation of an object can be a major operation in itself, but complex assembly operations do not fit the responsibility of the created objects. Combining such responsibilities can produce ungainly designs that are hard to understand. Making the client direct construction muddies the design of the client, breaches encapsulation of the assembled object or AGGREGATE, and overly couples the client to the implementation of the created object.
- Factories add elements to the design that do not correspond to anything in the model, but they are nonetheless part of the domain layer's responsibility.
- Shift the responsibility for creating instances of complex objects and AGGREGATES to a separate object, which may itself have no responsibility in the domain model but is still part of the domain design. Provide an interface that encapsulates all complex assembly and that does not require the client to reference the concrete classes of the objects being instantiated. Create entire AGGREGATES as a piece, enforcing their invariants.
- It possible to use simple constructors to create objects, but this should only be used for simple objects that are not aggregate roots or where the client absolutely needs direct control over the object construction.
- Construction of objects and aggregates, whether by factory or by constructor, should be atomic.
- Invariant logic should ideally go on the aggregate root object, but can sometimes be moved to the factory that creates the object if such logic is only required at construction time (i.e. assigning some ID that is immutable after creation).
- Factories that reconstitute objects from persistent storage (i.e. database) does not need to assign a new Entity ID, and is instead supplied the ID for retrieval from storage.  The Factory must also handle invariants slightly differently as, unlike creation of new objects, the object already exists in some form.
- An object does not represent a new entity just because we stored it in a database and retrieved it. To keep this distinction in mind, I refer to the creation of an instance from stored data as reconstitution.
- Be careful not to allow domain logic to creep into the queries required to retrieve objects from the database storage.
- A subset of persistent objects must be globally accessible through a search based on object attributes. Such access is needed for the roots of AGGREGATES that are not convenient to reach by traversal. They are usually ENTITIES, sometimes VALUE OBJECTS with complex internal structure, and sometimes enumerated VALUES. Providing access to other objects muddies important distinctions. Free database queries can actually breach the encapsulation of domain objects and AGGREGATES. Exposure of technical infrastructure and database access mechanisms complicates the client and obscures the MODEL-DRIVEN DESIGN.
- Use the Repository pattern to encapsulate all required objects of an aggregate and it's retrieval from storage.
- Transaction control is usually best left to clients of the repository as the client often has a better context to correctly initiate and commit units of work.
- Be careful not to combine repositories and factories into one to achieve a sort of "find or create" combined functionality.  This provides only a minor convenience yet muddies the distinction between new objects and existing which is often important.
- When designing database schema, you don't have to conform to one object - one table, and some database design rules, such as normalization, can be relaxed if it means the data model is not fighting with the domain model.
- Be sure to use the ubiquitous language when naming objects in the database schema to ease understanding and tie the data model to the domain model.

## Chapter 7 - Using The Language: An Extended Example
- This chapter looks at applying the modelling approaches from the previous chapters using a real world scenario of a Cargo Shipping Company.
- The company's mission is to Track key handling of customer cargo, Book Cargo in advance, and Send invoices to customers automatically when cargo reaches some point in its handling.
- We look at a simple box diagram model showing objects and associations and conclude: Multiple _Customers_ are involved with a _Cargo_, each playing a different role. The _Cargo_ delivery goal is specified. A series of _Carrier Movements_ satisfying the _Specification_ will fulfil the delivery goal.
- _Carrier Movement_ represents one particular trip by a particular _Carrier_  from one _Location_ to another. _Cargoes_ can ride from place to place by being loaded onto Carriers for the duration of one or more _Carrier Movements_.
- _Delivery History_ reflects what has actually happened to a _Cargo_, as opposed to the _Delivery Specification_, which describes goals. A _Delivery History_ object can compute the current _Location_ of the _Cargo_ by analysing the last load or unload and the destination of the corresponding _Carrier Movement_. A successful delivery would end with a _Delivery History_ that satisfied the goals of the _Delivery Specification_.
- We identify 3 user level application functions.  A _Tracking Query_ that can access past and present handling of a particular _Cargo_.  A _Booking Application_ that allows a new _Cargo_ to be registered and prepares the system for it.  An _Incident Logging Application_ that can record each handling of the _Cargo_ (providing the information that is found by the _Tracking Query_).
- In order to distinguish the Entities from the Value Objects, we look at the objects within the domain.  Customer, Cargo, Handling Event, Carrier Movement are all obvious entities as they require identity of their own and will be tracked via this identity.  Delivery History has a one-to-one relationship with Cargo so doesn't really have an identity of it's own, but they're not interchangeable so they must be entities.  Location and Delivery Specification are interchangeable as they relate to other objects and are identified only by their values and so they are value objects.
- To define Aggregates with the domain objects, _Cargo_ seems a good choice as the entity which is the aggregate root.  The aggregate also includes the _Delivery History_ and _Delivery Specification_ as these form the consistency boundary.
- For Repositories, we identify a _Customer_, _Cargo_, _Location_ and _Carrier Movement_ Repositories.  There's no _Handling Event_ repository as it's modelled as a collection on each _Delivery History_ which is contained inside the _Cargo_ repository responsible for the entire _Cargo_ aggregate.
- We can test our model by running through likely customer scenarios.  If a customer calls us to say that their cargo destined for Hackensack really needs to go to Hoboken instead, we can simply replace the _Delivery Specification_ value object inside the _Cargo_ aggregate with a new one.
- Users also tell us that repeat business from the same _Customer_ tends to be very similar, so we look into providing a way to create new _Cargoes_ based on old ones.  We can copy an old _Cargo_ aggregate, but we need to be careful how it's constituent entities should be initialised.  In this case, the _Cargo_ can be copied but with a new Tracking ID and the _Delivery History_ entity is initialised to an empty collection.
- We stop to consider an alternative design for the _Cargo_ aggregate.  Implementing a separate _Handling Event_ repository and making the _Delivery History_ query the _Handling Event_ data store rather than keeping the _Handling Events_ inside the _Cargo_ aggregate reduces contention when multiple users may need to add _Handling Events_ at the same time.
- In partitioning the various objects of the domain model into modules, we could naively use Entities, Value Objects and Services, but this results in an arbitrary grouping with the contents of each having low cohesion to each other.  A better grouping would be around Customers, Shipping and Billing.  This keeps cohesion high in each group and also uses the language of the business in their definitions.

## Chapter 8 - Breakthrough
- The traditional way of explaining object analysis involves identifying nouns and verbs in the requirements documents and using them as the initial objects and methods. This explanation is recognized as an oversimplification that can be useful for teaching object modelling to beginners. The truth is, though, that initial models usually are naive and superficial, based on shallow knowledge.
- We can refactor our design in many ways, and refactoring isn't just related to changing code without changing it's behaviour, but also to refactoring and refining the domain model which can change the code too.
- Major breakthroughs in model refactoring usually can't be predicted or forced, they are events that occur almost in spite of the team.  You must understand when this is happening and deal with it appropriately.
- An example of a real world breakthrough came when modelling a Loan Investment system.  Initially there were objects for Loans, Investments and Facilities (a mechanism for acquiring a loan) that allowed multiple investors to share a portion of a complete loan.  However, individual loan deposits could be negotiated between the investors to take different portions.  The breakthrough was re-modelling to the concept of a Share and a SharePie to allow the initial loan structure as well as the individual loan deposits.
- When the prospect of a breakthrough to a deeper model presents itself, it is often scary as such a change has much higher risk to the project, however, the most important progress in the project can come from such changes.
- To set the stage for a breakthrough, concentrate on knowledge crunching and cultivating a robust ubiquitous language and probe for important domain concepts and make them explicit in the model.

## Chapter 9 - Making Implicit Concepts Explicit
- During discussions and modelling activities, you must try to sensitize yourself to the hints that reveal lurking implicit concepts.
- Listen to the language the domain experts use. Are there terms that succinctly state something complicated? Are they correcting your word choice (perhaps diplomatically)? Do the puzzled looks on their faces go away when you use a particular phrase? These are hints of a concept that might benefit the model.
- You can often find the implicit object in awkward language in design discussions with the domain experts or in awkward parts of the code.  If you're struggling to add functionality and don't quite know which object it should apply to, perhaps there's an implicit object there that needs to be made explicit.
- Be aware that different domain experts see things different ways based on their experience and needs.  You'll need to speak with many different experts to get the complete picture.
- Sometimes, you not get to spend time with enthusiastic domain experts.  In such cases it can be beneficial to read any literature available on the domain area, if available.  Knowing even a little about the domain can encourage domain experts to be more open to helping you.
- Introductory object modelling can identify the "nouns and verbs" in a domain but there's often other concepts at play that are not so obvious.
- Explicit constraints are one such concept (i.e. an object modelling a bucket has a specific capacity and must enforce that invariant).  Make such enforcement of constraints explicit.  Model it as a separate method in the class rather than inline code in another method, with a suitable name to highlight the usage.
- The key to distinguishing a process that ought to be made explicit from one that should be hidden is simple: Is this something the domain experts talk about, or is it just part of the mechanism of the computer program?
- Business rules often do not fit the responsibility of any of the obvious entities or value objects, and their variety and combinations can overwhelm the basic meaning of the domain object. But moving the rules out of the domain layer is even worse, since the domain code no longer expresses the model.
- Use the Specification pattern to encapsulate business rules and constraints that can become complex and need to be modelled explicitly. 

## Chapter 10 - Supple Design
- The ultimate purpose of software is to serve users. But first, that same software has to serve developers.  The design must serve the developer working to change it. To be open to change, a design must be easy to understand, revealing that same underlying model that the client developer is drawing on.
- If a developer must consider the implementation of a component in order to use it, the value of encapsulation is lost.
- Name classes and operations to describe their effect and purpose, without reference to the means by which they do what they promise.  In the public interfaces of the domain, state relationships and rules, but not how they are enforced; describe events and actions, but not how they are carried out.
- Place as much of the logic of the program as possible into functions, operations that return results with no observable side effects. Strictly segregate commands (methods that result in modifications to observable state) into very simple operations that do not return domain information. Further control side effects by moving complex logic into value objects when a concept fitting the responsibility presents itself.
- State post-conditions of operations and invariants of classes and aggregates. If assertions cannot be coded directly in your programming language, write automated unit tests for them. Write them into documentation or diagrams where it fits the style of the project's development process.  Seek models with coherent sets of concepts, which lead a developer to infer the intended assertions, accelerating the learning curve and reducing the risk of contradictory code.
- When elements of a model or design are embedded in a monolithic construct, their functionality gets duplicated. The external interface doesn't say everything a client might care about. Their meaning is hard to understand, because different concepts are mixed together.
- Conceptual Contours emerge as the code is adapted to newly understood concepts or requirements and repeated refactoring eventually leads to suppleness.
- Decompose design elements (operations, interfaces, classes, and AGGREGATES) into cohesive units, taking into consideration your intuition of the important divisions in the domain. Observe the axes of change and stability through successive refactorings and look for the underlying CONCEPTUAL CONTOURS that explain these shearing patterns. Align the model with the consistent aspects of the domain that make it a viable area of knowledge in the first place.
- Try to eliminate dependencies from objects and models.  Associations between object are a dependency as are every method parameter and return value.  Low coupling is fundamental to object design.
- Most interesting objects end up doing things that can't be characterized by primitives alone.
- It can be favourable to write your code to express a declarative design. By using intention-revealing interfaces, side-effect free functions and assertions, you move closer to that goal.

## Chapter 11 - Applying Analysis Patterns
- Deep models and supple designs don't come easily, but when an experienced developer looking at a domain problem can draw on the memory of how the problem was solved before, this can help with insight into how best to create the domain model.
- Some of these patterns have been documented and shared and are known as Analysis Patterns.
- Sometimes there are parts of our programs that we don't even suspect have the potential to benefit from a domain model. They may have started very simply and evolved mechanistically. They seem like complicated application code, rather than domain logic. Analysis patterns can be particularly helpful in showing us these blind spots.
- Well-known analysis patterns are not necessarily the exact answer to your needs, but offer valuable leads and insight with the clean vocabulary, however, when you use a term from a well-known analysis pattern, take care to keep the basic concept it designates intact, in order to embed understanding and avoid problems.  Your ubiquitous language is enhanced when it includes terms that are widely understood.

## Chapter 12 - Relating Design Patterns to the Model
- Design Patterns (i.e. Gang of Four) can serve as both technical patterns and domain patterns.  On one level, they are technical design patterns in the code. On the other level, they are conceptual patterns in the model.
- Domain models contain processes that are not technically motivated but actually meaningful in the problem domain. When processes are required to be interchangeable, the Strategy design pattern can accommodate this.
- Whereas the conventional view of STRATEGY as a design pattern focuses on the ability to substitute different algorithms, its use as a domain pattern focuses on its ability to express a concept, usually a process or a policy rule.
- The Composite design pattern can be used to represent important domain objects that are composed of parts and which themselves are composed of parts, to any arbitrary depth.
- Design patterns should only be applied when needed and when it makes sense in the concepts of the domain.
- The Flyweight design pattern is an example of a design pattern that should not be used as a domain pattern.  The Flyweight pattern is purely an implementation detail and lacks congruity with the domain conceptually.

## Chapter 13 - Refactoring Toward Deeper Insight
- Three things to focus on are: Live in the domain, Keep looking at things in a different way, Maintain an unbroken dialog with domain experts.
- Refactoring is usually initiated when the code feels disconnected or contains awkwardness in relation to the domain model, or the language of the domain model seems disconnected from the domain experts.
- Use Exploration Teams (3 or 4 developers at least some of which have strong modelling skills along with 1 or 2 domain experts) to start a model refinement process, brainstorming for up to a couple of hours walking through scenarios with the objects of the model.
- Don't be afraid of using prior art as inspiration.  You can get ideas from books and other sources of knowledge about the domain itself.  Although these not be directly suitable as a model for a software program, they may well include organised concepts and some useful abstractions.
- Refactoring toward deeper insight both leads to and benefits from a supple design. 
- A supple design communicates its intent and helps limit mental overload. It is based on a deep model of the domain that is fine-grained only where most critical to the users. This makes for flexibility where change is most common, and simplicity elsewhere.
- Continuous refactoring should be the norm. If you wait until you can make a complete justification for a change, you've waited too long.
- Refactoring when: The design does not express the team's current understanding of the domain, Important implicit concepts need to be made explicit, You see an opportunity to make some important part of the design suppler.
- Don't introduce a "deeper model" that you couldn't convince a domain expert to use, no matter how elegant it seems.

## Chapter 14 - Maintaining Model Integrity
- As systems grow large, it becomes impossible to know them at a granular object level.  For this reason, we need to break down the model into smaller parts.  The challenge is to accomplish such modularity without losing the benefit of integration.
- The goal of the most ambitious enterprise system is a tightly integrated system spanning the entire business. Yet the entire business model for almost any such organization is too large and complex to manage or even understand as a single unit.
- Be careful not to re-use something that appears to be the same concept in different domain areas as they can often be quite different concepts.
- The most fundamental requirement of a model is that it be internally consistent, that its terms always have the same meaning, and that it contains no contradictory rules.
- An entire enterprise system will always consist of multiple models rather than one large model.  By ensuring we use multiple models aligning to logical separations in the business, we can ensure that the parts we want to unify stay that way, and the parts that are not unified don't cause confusion or corruption.
- Multiple models are in play on any large project. Yet when code based on distinct models is combined, software becomes buggy, unreliable, and difficult to understand. Communication among team members becomes confused. It is often unclear in what context a model should not be applied.
- Explicitly define the context within which a model applies. Explicitly set boundaries in terms of team organization, usage within specific parts of the application, and physical manifestations such as code bases and database schemas. Keep the model strictly consistent within these bounds, but don't be distracted or confused by issues outside.  This is a Bounded Context.
- A Bounded Context is a unique conceptual area of the complete domain that has it's own model, code and possibly database.  Bounded Contexts provide clarity to the team working within via model consistency and freedom from outside changes.
- We can recognise boundaries of contexts primarily via the ubiquitous language. If two areas use the same name for a concept that is actually two different concepts, or if two areas use two different names for the exact same concept, we may have found a context boundary.
- When a number of people are working in the same bounded context, there is a strong tendency for the model to fragment. The bigger the team, the bigger the problem, but as few as three or four people can encounter serious problems. Yet breaking down the system into ever-smaller contexts eventually loses a valuable level of integration and coherency.
- Identify each model in play on the project and define its bounded context. This includes the implicit models of non-object-oriented subsystems. Name each bounded context, and make the names part of the ubiquitous language.
- Continuous Integration is key to preventing model fragmentation within a bounded context. Compile and merge code frequently to ensure successful integration of both the model concepts and the implementation.
- Use a Context Map to show all of the bounded contexts and their relationships within the entire system.  Describe the points of contact between the models, outlining explicit translation for any communication and highlighting any sharing. Map the existing terrain. Take up transformations later.
- Context Maps define translations that may be required for one bounded context to effectively communicate with another.  Such translations can be implemented in their own objects and will be shared between the two contexts.
- Contact points with other bounded contexts are particularly important to test.
- When two bounded contexts are very closely related, there may be some aspects of the contexts that can be shared between the teams.  This is a Shared Kernel of objects and components that both teams work upon and agree to share responsibility for.  Continuous integration is of particular importance here.
- Often there can be one "upstream" context that naturally feeds into another "downstream" context.  This is the Customer/Supplier relationship. In planning sessions, make the downstream team play the customer role to the upstream team. Negotiate and budget tasks for downstream requirements so that everyone understands the commitment and schedule and jointly develop automated acceptance tests to validate the communication between the contexts.
- Use the Conformist pattern when two development teams have an upstream/downstream relationship in which the upstream has no motivation to provide for the downstream team's needs.  This is often prevalent when the upstream is a third-party system or component or is in a politically disconnected area of the business.
- For Conformists contexts, eliminate the complexity of translation to the other context by slavishly adhering to the model of the upstream team. Although this cramps the style of the downstream designers and probably does not yield the ideal model for the application, it enormously simplifies integration and allows you to share the ubiquitous language with your supplier team.
- Use an Anti-Corruption Layer to strengthen a translation between two bounded contexts.  Simple translations are usually sufficient when bridging well-designed models with co-operative teams, but if the other side of the boundary starts to leak through, an Anti-Corruption Layer can help defend against that.  This is often employed when integrating against a poorly modelled legacy system.
- Anti-Corruption Layers can be a large and complex piece of software in it's own right, often designed as a set of services for it's public interface and making use of facade and adapter design patterns.
- Simple translation layers are often used when primitives have simple mapping between the contexts.  Anti-Corruption Layers are often used when entire subsets of the model need to be translated between the contexts.
- The Separate Ways pattern is used when two bounded contexts do not integrate directly at all.  This is often employed when the benefit of integration outweighs the costs of implementation.  The features can still be organized in middleware or the UI layer, but there will be no sharing of logic, and an absolute minimum of data transfer through translation layers—preferably none.
- Use the Open Host Service pattern when a subsystem has to be integrated with many others avoiding the need to customise a translator for each.
- Define a protocol that gives access to your subsystem as a set of services. Open the protocol so that all who need to integrate with you can use it. Enhance and expand the protocol to handle new integration requirements, except when a single team has idiosyncratic needs. Then, use a one-off translator to augment the protocol for that special case so that the shared protocol can stay simple and coherent.
- Use a Published Language when two contexts have to communicate without polluting the model of either system.  This is a well-documented shared language that can express the necessary domain information as a common medium of communication, translating as necessary into and out of that language.
- Recognizing multiple, clashing domain models is really just facing reality. By explicitly defining a context within which each model applies, you can maintain the integrity of each and clearly see the implications of any particular interface you want to create between the two.
- Getting the correct sizing for bounded contexts can be difficult.  Larger contexts have better flow between user tasks and are easier to understand as one coherent model instead of multiple models.  Smaller bounded contexts reduce communication overhead within the team, continuous integration and the act of modelling become easier.
- Generally speaking, there is a correspondence of one team per bounded context. One team can maintain multiple BOUNDED CONTEXTS, but it is hard (though not impossible) for multiple teams to work on one together.
- Be aware of deployment considerations dependent upon the nature of the relationship between two or more contexts that communicate together. For example, Customer/Supplier or Shared Kernel relationships will need careful coordinated deployments that have been tested together.  Separate Ways can make deployments far easier.
- To implement Domain-Driven Design on an already existing project, the first step is to define bounded contexts according to the way things are now. This is crucial. To be effective, the context map must reflect the true practice of the teams, not the ideal organization you might decide on by following the guidelines just described. The next step is to tighten up the team's practices around that current organization and improve continuous integration with the contexts. Then you are ready of consider changes to the context boundaries and relationships. 
- When seeking to combine two bounded contexts into one, consider first moving to a shared kernel.  Moving beyond the shared kernel means unifying the model and ensuring the two teams have continuous integration together and a unified language.
- To build a new DDD-driven system to replace a legacy system, consider implementing functionality one piece at a time with an anti-corruption layer that allows communication with the legacy system.  Once functionality is sufficiently moved to the new system, focus on attempting to shrink the anti-corruption layer as parts of the legacy system are phased out.

## Chapter 15 - Distillation
- Distillation is the process of separating the components of a mixture to extract the essence in a form that makes it more valuable and useful.  Strategic distillation of a domain model uses layered architecture to aid team members in grasping the overall design, guides refactoring, facilitates communication.
- Distillation efforts are motivated by the desire to extract the single most valuable part that makes the software worth building, the "Core Domain".
- In designing a large system, there are so many contributing components, all complicated and all absolutely necessary to success, that the essence of the domain model, the real business asset, can be obscured and neglected.
- Not all parts of a system design are going to be equally refined but the model's critical core must be sleek and fully leveraged to create application functionality, even if developers might rather spend time on other parts of the system that could be more technically interesting.
- Boil the model down. Find the Core Domain and provide a means of easily distinguishing it from the mass of supporting model and code. Bring the most valuable and specialized concepts into sharp relief. Make the Core small and assign the best developers to focus on the Core Domain.
- If you need to keep some aspect of your design secret as a competitive advantage, it is the Core Domain.
- Generic subdomains are the contrast to the core domain.  They are those areas of the business that are usually shared amongst many businesses and are not unique to any such as expense ledgers, organisation charts, accounting etc.
- Identify cohesive subdomains that are not the motivation for your project. Factor out generic models of these subdomains and place them in separate modules. Once they have been separated, give their continuing development lower priority than the Core Domain and strongly consider off the shelf solutions.
- A Domain Vision Statement focuses on the nature of the domain model and how it is valuable to the enterprise.  It is a short description of the Core Domain and the value it will bring, the "value proposition". Ignore those aspects that do not distinguish this domain model from others. Show how the domain model serves and balances diverse interests. Keep it narrow. Write this statement early and revise it as you gain new insight.
- The Domain Vision Statement can be used as a guidepost that keeps the development team headed in a common direction in the ongoing process of distilling the model and code itself. It can be shared with nontechnical team members, management, and potentially even customers.
- A Highlighted Core document expands upon the Domain Vision Statement and describes the critical behaviours and relationships of the essential conceptual objects within the Core Domain.  This document is often around 3 to 7 pages and will flag the elements of the Core Domain making it effortless for a developer to know what is in or out of the CORE.
- Although the Domain Vision Statement and Highlighted Core documents inform and guide, they do not actually modify the model or the code itself.
- Partition a conceptually Cohesive Mechanism into a separate lightweight framework, paying attention to well-documented categories of algorithms. Expose the capabilities of the framework with an intention-revealing interface allowing other element of the domain to focus on the "what" instead of the "how".  An example of such usage would be an organisational chart which is likely to be represented by a graph - a well-understood concept in computer science.
- You almost always want to remove Cohesive Mechanisms from the Core Domain. The one exception is when a Cohesive Mechanism is itself proprietary and a key part of the value of the software.
- It's possible to create a Segregated Core. This involves refactoring the model to separate the Core Domain concepts from supporting sub-domains and strengthening the cohesion of the Core Domain while reducing its coupling to other code.  Create a Segregated Core when you have a large Bounded Context that is critical to the system, but where the essential part of the model is being obscured by a great deal of supporting capability.
- We can use an Abstract Core pattern to make excessive interaction between subdomains more manageable.  Identify the most fundamental concepts in the model and factor them into distinct classes, abstract classes, or interfaces. Design this abstract model so that it expresses most of the interaction between significant components. Place this abstract overall model in its own module, while the specialized, detailed implementation classes are left in their own modules defined by subdomain.
- Modelling an ABSTRACT CORE requires a deep understanding of the key concepts and the roles they play in the major interactions of the system.
- Although a breakthrough to a deep model provides value anywhere it happens, it is in the CORE DOMAIN that it can change the trajectory of an entire project.

## Chapter 16 - Large-Scale Structure
- A "large-scale structure" is a language that lets you discuss and understand the system in broad strokes, devise a pattern of rules or roles and relationships that will span the entire system and that allows some understanding of each part's place in the whole—even without detailed knowledge of the part's responsibility.
- Having no overarching architecture can produce systems that make no sense when viewed as a whole, but some architectures can straitjacket a project with up-front assumptions and take power away from developers of particular parts of an application so development gets dumbed down to fit the architectural constraints.
- Large-scale structure should be applied when a structure can be found that greatly clarifies the system without forcing unnatural constraints on model development. Let this conceptual large-scale structure evolve with the application, possibly changing to a completely different type of structure along the way. Don't over-constrain the detailed design and model decisions that must be made with detailed knowledge.  An ill-fitting structure is worse than no structure.
- Software designs tend to be very abstract and hard to grasp. Developers and users alike need tangible ways to understand the system and share a view of the system as a whole.  A System Metaphor is a loose, easily understood, large-scale structure that it is harmonious with the object paradigm and is frequently used as part of an Extreme Programming (XP) approach.
- When a concrete analogy to the system emerges that captures the imagination of team members and seems to lead thinking in a useful direction, adopt it as a large-scale structure. Organize the design around this metaphor and absorb it into the ubiquitous language. The System Metaphor should both facilitate communication about the system and guide development of it. This increases consistency in different parts of the system, potentially even across different bounded contexts. But because all metaphors are inexact, continually re-examine the metaphor for overextension or inaptness, and be ready to drop it if it gets in the way.
- Use of Responsibility Layers can help identify the responsibilities of the larger systems, just as aggregates and bounded contexts define responsibilities of smaller component parts.
- Be careful to avoid a purely technical layering, based only upon technological concerns and strive instead for layers separated by responsibility or coarse-grained feature sets.  These layers should be a grouping of concerns that tell a story, such as grouping object from the same bounded context into operational, capability, decision making layers etc.
- Layers should be storytelling and communicate the basic business realities or priorities of the domain and the business.
- It is best to keep the layering system simple. Going beyond four or possibly five becomes unwieldy.
- Use Knowledge Levels to explicitly define areas of the model that might actually be meta in concept (i.e. parts of the model are about other parts of the model).  Operations level in the model is the model of the domain itself, whilst Knowledge Level of the model are those parts that are about the operation level parts.
- Knowledge Level parts of a model are often identified by having roles and relationships between entities of the model that can vary in different situations (e.g an organisational employee hierarchy).
- A Knowledge Level creates a distinct set of objects that can be used to describe and constrain the structure and behaviour of the basic model. It keeps these concerns separate as two "levels," one very concrete, the other reflecting rules and knowledge that a user or superuser is able to customize.
- Be careful not to overuse the Knowledge Level pattern. It can unravel complexity by freeing operations objects from the need to be jacks-of-all-trades, but the indirection it introduces does add some of that obscurity back in, making the overall application overly complex to configure and use.
- We can use a Pluggable Component Framework when a variety of applications need to interoperate, based upon the same abstractions but designed independently and by independent teams that do not work closely together.
- To implement the Pluggable Component Framework, we should distil an Abstract Core of interfaces and interactions within a Shared Kernel and create a framework that allows diverse implementations of those interfaces.
- A Pluggable framework does have some downsides as it constrains implementers and requires precision in the design of the interfaces and a deep enough model to capture the necessary behaviour in the Abstract Core.
- The most important contribution of the large-scale structure is conceptual coherence, and giving insight into the domain. Each structural rule should make development easier.
- It's easy to think that large-scale structure is antithetical to modern agile development and implies big design up front, however, iterative and agile development works very well so long as it can take many iterations to fully flesh out a complete domain model.  The key is to ensure that focus on the domain as a whole is maintained within each iteration, rather than a myopic focus on only one small part of it.

## Chapter 17 - Bringing The Strategy Together
- The three basic principles of strategic design (context, distillation, and large-scale structure) are not substitutes for each other; they are complementary and interact in many ways.
- In very simple scenarios, the meanings of layer names are restricted to a single bounded context, however, it's likely that layers will cut through multiple contexts.
- If you have a legacy system whose organization is inconsistent with your desired large-scale structure you do not have to give up or modify your own layers and structure but you must explicitly acknowledge the actual place the legacy fits within the structure.  This may even help to characterize and define the legacy system.
- The concepts of large-scale structure and distillation also complement each other.
- When attempting strategic design on an existing system, you need to start from a clear assessment of the current situation.  Draw a context map and determine if it's consistent or if there are ambiguous situations. Is there a ubiquitous language? Is it rich enough? Is there a Domain Vision Statement and is the Core Domain clearly identified.  Finally, do the developers have the requisite skills and are they knowledgeable enough, and indeed interested in, the domain.
- Strategic Design decision making doesn't (and probably shouldn't) come from the traditional ivory tower architect.  It can come from strong self-organising teams or even a separate customer-focused architecture team that continually and closely collaborates with the other teams.
- The six essentials for strategic design decision making are that decisions must reach the entire team, the decision process must absorb feedback, the plan must allow for evolution, architecture teams must not commandeer all of the organisations best developers, strategic design requires minimalism and humility, remember that objects are specialist and developers are generalists, and finally, beware the master plan that tries to be completely prescriptive up front and becomes too rigid to allow for the natural organic growth and change that occurs over time.
- Finally, remember that domain modelling requires imagination and self-discipline. Tools that help us think or avoid distraction are good. Efforts to automate what must be the product of thought are naive and counterproductive.
