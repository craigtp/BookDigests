# Book Digest: Domain-Driven Design Distilled

Title     : Domain-Driven Design Distilled  
Author(s) : Vaughn Vernon  
ISBN-10   : 0134434420  
ISBN-13   : 978-0134434421

## Chapter 1 - DDD For Me
* DDD is a set of advanced techniques for modelling complex software projects.
* Many teams don't give design within their software projects much thought.  Instead, they perform the "task board shuffle" (the moving of individual task cards from left to right across a Kanban board with little concern for the overall system architecture).
* Some of the most insidious problems that DDD can seriously help with are: Software Development being considered a cost centre rather than a strategic advantage (although if management culture is firmly fixed, this may be unfixable), the database (and resulting data model) being given too much priority in the whole system design, lack of emphasis on domain events and correctly naming objects and operations according to the business purpose they fill, embedding business logic in UI or data persistence components, wrong abstractions or attempting to overly generalize solutions rather than concentrating on the actual business problems.
* DDD helps with good design, and there's always design present in software, even if it's not explicit.  That's because the opposite of good design is not no design, it's bad design.
* One of Scrum's most valuable tenets is that of "Knowledge Acquisition" - a better understanding of the business requirements and of the needs that the software will address.  This is also known as "buying information" as it always comes at a cost.
* With DDD, we strive for good design, but more importantly, effective design.
* Effective design starts with "Strategic Design" - this is the broad brushstrokes of the whole system and involves determining the "bounded contexts" and the "ubiquitous language" used within them.  Strategic Design is also about determining the Subdomains and how Bounded Contexts collaborate and communicate with each other through "Context Mapping".
* Next is "Tactical Design" - this is the finer brushwork to fill in the finer details.  This is using the "Aggregate" pattern to right-size clusters of domain entities and value objects.  It's also about determining the Domain Events.
* Finally, DDD is mostly about constant collaboration and learning between the development team and the business team.

## Chapter 2 - Strategic Design with Bounded Contexts and the Ubiquitous Language
* A Bounded Context is a semantic contextual boundary. Each component within the boundary has a specific meaning and does specific things which are context specific and semantically motivated.
* Initially, your Bounded Context will be part of your problem space. As it evolves, it will become part of your solution space.
* The "problem space" is where you perform high-level strategic analysis and design steps within the constraints of a given project.  The "solution space" is where you actually implement the solution that your problem space discussions identify as your "Core Domain".
* You should have separate software repositories for each Bounded Context and each Bounded Context should have separate teams working on each one. A single team can work on multiple contexts but never multiple teams working on one Context.
* Bounded contexts break up your entire solution space into manageable chunks ensuring that your overall model isn't one large "big ball of mud" spanning multiple unrelated (or only tangentially related) concepts. Different business functions tend to be good indicators of Bounded contexts.
* The other important design strategy is the ubiquitous language. This is the language of the business that is used within the software solution to name and define concepts, entities events and other artefacts of the business domain.
* It's important that we identify the "core" domain of the business. There may be more than one overall domain, but identifying the core allows us to focus our efforts on this. It there are multiple domains, you should ideally have different teams working on each domain.
* We get the Ubiquitous language from discussions with developers and domain experts.  Domain Experts are people within the business who are experts/leaders for that given domain area.
* We identify which concepts belong in the core domain by asking whether each of the concepts adheres to the ubiquitous language of the domain.  For example, if building an online scrum/agile management website, one may have a concept of "billing" or invoice to charge users of the software however the concept of billing does not exist within the core domain of agile itself, therefore "billing" is NOT part of the core domain.
* A good way to start developing the ubiquitous language is to start with the nouns used within the business domain. Be careful not to constrain yourself only to nouns though, also consider concrete scenarios about what the domain model is supposed to do.
* Adding in people to the language helps to give additional perspective and can raise additional questions (i.e. "Clicking the button does X" becomes "The product owner, Steve, clicks the button, which does X").
* In order to further detail the ubiquitous language and turn your written scenarios into usable artefacts within software, you can use the "specification by example" aka behaviour-driven development technique.
* DDD, on a technological level is often implemented using the "ports and adapters" architecture. This allows a domain at the centre which is free of technology concerns and those concerns lie on the outside of the architecture and are accessed via adapters.

## Chapter 3 - Strategic Design with Subdomains
* Bounded contexts can contain one or more subdomains.  Ideally, there should be a one-to-one mapping of bounded contexts and subdomains.  If you must have more than one subdomain in a bounded context, the subdomains should be separated by a module (i.e. a namespace in C#).
* Subdomains are a sub-part of the overall business model and represent a single, logical domain model, usually coinciding with a business area that has a specific "Domain Expert" associated with it.
* Subdomains can be one of 3 types:  Core Domain - This is the core business domain and will be highly bespoke and have the most custom development effort.  Supporting Subdomain - This is a supporting domain that requires custom development but may not have as much effort applied as the core domain and may be outsourced.  It is still important because the Core Domain cannot succeed without it.  Generic Subdomain - This domain solution may be outsourced, or even be an off the shelf package.
* In legacy systems, not developed using DDD, there are likely to be multiple logical domain models inside the single legacy system.  Each of these logical domain models can be thought of as a subdomain.

## Chapter 4 - Strategic Design with Context Mapping
* Integration between bounded contexts is known as context mapping.
* Context mapping allows multiple different bounded contexts to have their own understanding of a given piece of the domain model using their own ubiquitous language.  For example, two bounded contexts could have the concept of a "policy" but it might be a very different domain entity for each bounded context.
* Context mappings can be either team mappings (between the actual teams of people that work on each context) or technical mappings (where some technological artefact must exist and be shared by both domains).
* Context mappings can represent many types of relationships and/or integrations.  Partnerships, Shared Kernels, Customer-Supplier, Conformist, Anti-Corruption Layer, Open Host Service, Published Language, Separate Ways and finally Big Ball Of Mud.
* Partnership mappings are where two teams working on two bounded contexts have some dependence upon each other so need to synchronize their work and will often succeed or fail together.  
* Shared Kernel mappings are an intersection of two bounded contexts such that there are some artefacts of the contexts that are directly shared.  Shared Kernel are often difficult to maintain and require extensive open communication and collaboration between the two teams.
* Customer-Supplier mappings are where the one team is "upstream" in the relationship.  The Supplier holds the sway in the relationship and determines what the Customer will get and when. 
* Conformist mappings are similar to the customer-supplier except that the "downstream" team must conform to and be dictated to by the upstream team (i.e. consider having to conform to a 3rd party API).
* Anti-Corruption Layer mapping has the downstream team create a translation layer between it's ubiquitous language / model and that of the other team, preventing any concepts from the other team from "bleeding" into the ubiquitous language / model of the downstream team.  This is not only a team mapping but also largely a technical one.  Think of this as like hiring a translator to communicate between two teams speaking different spoken languages.
* Open Host Service mapping defines an "open" protocol or interface on one bounded context through which any other bounded contexts must communicate.  It is "open" with a clearly defined and published API.  This kind of mapping can allow a consuming context to forego implementing it's own Anti-Corruption Layer since it will "pull" data from other context via known API's and can perform it's own translations on that data.
* Published Language mapping is similar to the Open Host Service mapping, but represents just the publishing of a known document of how communication should be achieved.  In practice, Open Host Service mappings usually provide both the API and the published document (think an API documented with Swagger/OpenAPI).
* Separate Ways mapping is really the opposite of collaboration between bounded contexts and represents two contexts doing entirely their own thing without consumption or integration with any other context.
* Big Ball Of Mud is the antithesis of a system broken down into bounded contexts.  All context are together in one large multi-faceted model.  This is problematic because a growing number of aggregates cross-contaminate due to unwarranted connections and dependencies and maintenance on one area of the model can have knock-on "ripple" effects that cause many issues.  Only tribal knowledge and developers who speak the entire language of the domain can save the system from complete collapse.
* Context mappings can be implemented in a number of technical ways.  The most common ways are RPC via SOAP (Remote Procedure Calls), RESTful HTTP or Messaging (often Publish-Subscribe model).  Sometimes database or file system integrations can exist too, but these should really be avoided if at all possible.  Messaging integrations will publish Domain Events for other contexts to respond to.
* Receivers of messages should be designed to be idempotent as the messaging mechanism should be "at-least-once" delivery (which means the messaging component may send the message more than once).
* When a given domain artefact (i.e. a "policy" entity) exists within multiple contexts, the owner context can create the entity and publish a domain event which related contexts can receive in order to create their own "policy" artefacts specific to their context.  The Id of the "main" artefact is included in the event and stored to allow back-referencing to the original / "main" artefact.
* There's a trade-off between publishing lots of data in the creation domain event such that consumers don't need to query the source for further data vs. only publishing the Id and causing all consumers to query-back to get further data.

## Chapter 5 - Tactical Design with Aggregates
* Each large concept within a bounded context will be an aggregate.  Aggregates are composed of one or more entities or value objects and have a single "root" entity that acts as the aggregate root and provides the aggregate with it's name.
* An Entity is a specific individual thing that has a unique identifier distinguishing it from all other entities of the same type (i.e. a "Customer" would be an entity with a CustomerId as it's unique identifier).  Entities are usually mutable but may be immutable.
* A Value Object models an immutable conceptual whole and does not have a separate unique identifier but uses the entirety of it's value as the identity.  Value Objects are often used to describe, quantify or measure and entity. (i.e. a "Customer" entity may have a status (normal, preferred, VIP) represented by a value object).
* Aggregates form a transactional consistency boundary.  This means that all modifications to entities and value objects inside an aggregate must be consistent, according to business rules, inside a single transaction.
* There are four rules to Aggregate design:  Protect business invariants inside Aggregate boundaries, Design small Aggregates, Reference other Aggregates by Identity only, Update other Aggregates using eventual consistency.
* Protecting business invariants is accomplished by an aggregate's transactional boundary.
* Aggregates should be designed to be small.  One way of knowing if an aggregate is too large is if a non-root entity represents a collection of entities that could grow very large over time - this could indicate that a new aggregate is required with items from this entity collection as their own aggregate roots.
* Updating of other aggregate using eventual consistency is achieved with domain events.  If an aggregate changes, it publishes a domain event (i.e. "CustomerUpdated") which other interested aggregates can subscribe to in order to update their own internal entities with the modified data (if required).
* Beware of creating Anemic Domain Models.  These are models that have only properties (get/set) with no real business behaviour.  This often happens when there is a technical rather than business focus during modelling.
* When designing the code classes for Aggregates, be careful not to introduce too many public setters (i.e. for properties) as this can lead to an anemic domain model.  Prefer behavioural methods for changing the values and state of entities, value objects and their properties inside the aggregate.
* Be careful to always choose the rights abstractions!  You should follow the ubiquitous language of the domain and not attempt to create further abstractions (perhaps trying to account for some potential  future requirement) as this is wasteful, time-consuming and can cause confusion if the non-ubiquitous language terms "bleed" out into other areas of the software.  (i.e. If modelling a Scrum product, there's concepts of "Project" and "BacklogItem" - Don't try to create a "ScrumElement" that can be either of the two aforementioned things!)
* In order to design correctly sized aggregates, start with each aggregate having only one entity.  Then consider which aggregates need to update when another aggregate updates and also the time when this update must take place.  For all immediate updates, move those entities into the same aggregate whose update causes the change.  For aggregates than can update over time, keep them separate and perform the update with eventual consistency.
* Be careful that the business doesn't insist that all updates must happen immediately.  It's unlikely that all updates must happen immediately.  To help prevent falling into this trap, consider how data "updates" might happen if the business still ran by means of only paper based systems!
* Large aggregates are much more difficult to unit test.  Keep unit tests clear and succinct by ensuring that your aggregates are kept small.

## Chapter 6 - Tactical Design with Domain Events
* A Domain Event is a record of some business-significant occurrence in a Bounded Context and are an important tool for strategic design.
* It's often important that Domain Events are causally related.  This means that events must happen in a specific order for the overall state of the domain to make sense.
* Your Domain Event type names should be a statement of a past occurrence, that is, a verb in the past tense. I.e. ProductCreated, ReleaseScheduled, ItemShipped etc.  They should be made up of the name of the command or name of the aggregate name along with the action that was applied/taken.  For example, a CreateProduct command would raise a ProductCreated event.
* The properties that a Domain Event should have should be the same properties that were present on the command that caused the event to to be raised, but be careful that you don't overload the domain event with so much data that what actually happened to the entity/aggregate is lost.
* Changes to the state of aggregates and domain events should be persisted in the same transaction.  If using Event Sourcing then the state of the aggregate is fully represented by the domain events themselves.
* Domain Events should always ideally be persisted in an event store rather than an RDBMS (even if the aggregates are stored in an RDBMS) as this preserves the causal ordering of events.
* It's the responsibility of consumers of domain events to ensure causality when events are consumed.  Sometimes certain events can be ignored as they may be superseded by later events.
* Domain Events can also be caused by other means, for example a timer expiring or an end-of-week expiring time frame.  These are modelled as domain events but not as commands and will have names that are part of the ubiquitous language such as "Fiscal Year Ended".
* Commands could be rejected by a consumer (i.e. can't sell a product if not enough stock available) but a Domain Event is a matter of history and cannot be denied.
* Domain Events can be stored in an Event Sourced persistence layer.  This means that instead of saving the entire state of the aggregate with each update, only the actual parts that have changed are saved.  The complete aggregate is reconstituted by replaying the events, from first to last, applying each on top of the previous.  Caching of aggregates under heavy usages is common with event sourcing as is snapshots of complete states of aggregates at various points in time in order to prevent the need to replay all events from the beginning of time in order to reconstitute the aggregate.

## Chapter 7 - Acceleration And Management Tools
* One tool that can really help with understanding a business domain and determine the domain models that may be required is Event Storming.  This activity has both developers and Domain Experts collaborate on modelling primarily the "events" (things that happen) and the "commands" (things that cause events) within the Core Domain, by using sticky notes on a large wall.  The x axis represents time, and sticky notes are applied to the wall in a loose fashion for events, commands, processes, users and other important domain artefacts.
* Event Storming may need to be performed over a number of sessions to really allow the full domain design model to emerge as the sticky notes will (and should) be moved, removed and improved upon throughout the sessions as the domain design becomes clearer and more complete.
* Some other approaches to determining the domain model are "Executable Specifications" as defined in the book "Specification By Example" by Gojko Adzic,  "Impact Mapping" from the book of the same name, also by Gojko Adzic, and "User Story Mapping" from the book of the same name by Jeff Patton.
* When trying to manage a project run using Domain Driven Design, it's important to remember that a large part of the project is "knowledge acquisition" and in some management methodologies, this can be ignored in favour of relentless delivery.
* One of the most important means to successfully employing DDD on a project is to hire good people. There is simply no replacement for good people.
* Use SWOT analysis.  This is Strengths, Weaknesses, Opportunities and Threats.  This involves mapping all the characteristics of the business or project into these four designations using sticky notes on a board with the SWOT terms in four separate quadrants.  From here, you promote the good characteristics (Strengths & Opportunities) and outline plans to mitigate the bad ones (Weaknesses & Threats).
* During the lifetime of a DDD project, you have to continually "buy" knowledge about the domain.  This means continually making time for modelling within sprints or timeboxed pieces of work.  This is best done with frequent Event Storming sessions.
* To help estimation of tasks, identify the component's Domain Event, Command and Aggregate.  From here, estimate a time in hours for Easy, Moderate and Complex implementations of each.  Adding the hours for the event, command and aggregates will give a good quality estimate for easy, moderate and complex tasks.
* It can be helpful, when breaking down work into actual tasks for a kanban board, to keep all of the commands and events used by a single aggregate in a single task.  Avoid tasks that are too granular.
* One of the most difficult parts of a DDD project is getting time from Domain Experts.  Because of this, it's important to make the limited time you have with them count.  You should clearly identify the areas where the domain experts are absolutely required and schedule this in advance.
* Domain Experts are required participants for all Event Storming activities.  This also extends to the creation of the DDD models, aggregates and events that stem from the Event Storming sessions with a particular attention paid to the naming and the ubiquitous language.  Domain Experts are also required for tests that developers write to verify correctness of the DDD model & aggregate once coded.